#!/usr/bin/env python2.7
# -*- coding:utf-8 -*-

import sys
import json
import argparse
import traceback
import cmd

from tablestore import *

GLOBAL_CONF = None

VERSION = "2017-11-05"
GLOBAL_CONFIG_FILE = ".table_store_config"
GLOBAL_HISTORY_FILE = ".history"

def _get_ts_config():
    out = {}
    try:
        with open(GLOBAL_CONFIG_FILE) as fp:
            out = json.load(fp)
    finally:
        return out

def _save_ts_config(conf):
    global GLOBAL_CONF
    GLOBAL_CONF = conf
    with open(GLOBAL_CONFIG_FILE, "w") as fp:
        fp.write(json.dumps(conf, indent=4))

def _handle_config(args):
    conf = _get_ts_config()

    if args.instance:
        conf['instance'] = args.instance
    if args.endpoint:
        conf['endpoint'] = args.endpoint
    if args.accessid:
        conf['accessid'] = args.accessid
    if args.accesskey:
        conf['accesskey'] = args.accesskey
    
    print json.dumps(conf, indent=4)
    _save_ts_config(conf)

def _check_config_param(conf, key):
    if not conf.get(key):
        raise Exception("The %s is not exist, please config --%s"%(key, key))

def _get_ots_client():
    global GLOBAL_CONF

    _check_config_param(GLOBAL_CONF, "endpoint")
    _check_config_param(GLOBAL_CONF, "accessid")
    _check_config_param(GLOBAL_CONF, "accesskey")
    _check_config_param(GLOBAL_CONF, "instance")

    return OTSClient(
        "http://" + str(GLOBAL_CONF["endpoint"]),
        str(GLOBAL_CONF["accessid"]),
        str(GLOBAL_CONF["accesskey"]),
        str(GLOBAL_CONF["instance"])
    ) 

def _handle_list_table(args):
    ots = _get_ots_client()
    tables = ots.list_table()
    for t in tables:
        print t

def _get_pk(input):
    items = input.split(",")

    out = []
    for i in items:
        ss = i.split(":")
        if len(ss) != 2:
            raise Exception("Primary Key format error, expect '{ColumnName}:{Type}'")

        out.append((ss[0], ss[1].upper()))

    return out

def _utf8(input):
    return str(bytearray(input, "utf-8"))

def _get_pk_value(meta, input, default=None):
    if input:
        items = input.split(",")
        if len(meta) != len(items):
            raise Exception("The count of primary key is %s, but input len is %s"%(len(meta), len(items)))
        out = []
        for i in range(0, len(items)):
            p = meta[i]
            if p[1] == "INTEGER":
                out.append((_utf8(p[0]), int(items[i])))
            elif p[1] == "STRING":
                out.append((_utf8(p[0]), _utf8(items[i])))
            else:
                raise Exception("Not suppert the type(%s)."%(p[1]))

        return out
    else:
        out = []
        for m in meta:
            out.append((_utf8(m[0]), default))
        return out

def _get_attr_value(input):
    items = input.split(",")
    out = []
    for i in items:
        ss = i.split(":")
        if len(ss) != 3:
            raise Exception("Format error")

        if ss[2].upper() == "INTEGER":
            out.append((_utf8(ss[0]), int(ss[2])))
        else:
            out.append((_utf8(ss[0]), _utf8(ss[2])))

    return out

def _get_pk_and_attr_value(meta, input):
    items = input.split(" ") 
    if len(items) != 2:
        raise Exception("The line format error")

    pk = _get_pk_value(meta, items[0])
    attr = _get_attr_value(items[1])

    return pk, attr

def _get_cu(input):
    items = input.split(",")
    if len(items) != 2:
        raise Exception("Input cu format error, expec '{ReadCU},{WriteCU}'")

    return int(items[0]), int(items[1])

def _handle_create_table(args):
    schema_of_primary_key = _get_pk(args.primary_key)
    table_meta = TableMeta(args.name, schema_of_primary_key)
    table_option = TableOptions(int(args.ttl), int(args.version))
    read, write = _get_cu(args.cu)
    reserved_throughput = ReservedThroughput(CapacityUnit(read,write))
    ots = _get_ots_client()
    ots.create_table(table_meta, table_option, reserved_throughput)
    print "OK"

def _handle_delete_table(args):
    ots = _get_ots_client()
    ots.delete_table(args.name)
    print "OK"

def _handle_put_row(args):
    ots = _get_ots_client()
    meta = ots.describe_table(args.name)
    pk_meta = meta.table_meta.schema_of_primary_key
    pk = _get_pk_value(pk_meta, args.primary_key)
    attr = _get_attr_value(args.attribute)
    row = Row(pk, attr)
    consumed, return_row = ots.put_row(_utf8(args.name), row)
    print "ReadCU:%s, WriteCU:%s"%(consumed.read, consumed.write)
    print "OK"

def _handle_get_row(args):
    ots = _get_ots_client()
    meta = ots.describe_table(args.name)
    pk_meta = meta.table_meta.schema_of_primary_key
    pk = _get_pk_value(pk_meta, args.primary_key)
    consumed, return_row, next_token = ots.get_row(_utf8(args.name), pk, max_version = 1)
    print "PrimaryKey:%s"%(str(return_row.primary_key))
    print "Attribute:%s"%(str(return_row.attribute_columns))
    print "ReadCU:%s, WriteCU:%s"%(consumed.read, consumed.write)
    print "OK"

def _handle_get_range(args):
    ots = _get_ots_client()
    meta = ots.describe_table(args.name)
    pk_meta = meta.table_meta.schema_of_primary_key

    begin_pk = _get_pk_value(pk_meta, args.begin, INF_MIN)
    end_pk = _get_pk_value(pk_meta, args.end, INF_MAX)

    consumed_counter = CapacityUnit(0, 0)
    token = ots.xget_range(
        _utf8(args.name),
        Direction.FORWARD,
        begin_pk,
        end_pk,
        consumed_counter,
        max_version = 1
    )

    count = 0
    for r in token:
        count = count + 1
        if count % int(args.pagesize) == 0:
            if args.interval:
                time.sleep(float(args.interval))

        print "%s, %s" %(r.primary_key, r.attribute_columns)

    print "OK, CU: (%s, %s), Count: %s"%(consumed_counter.read, consumed_counter.write, count)

def _handle_import(args):
    ots = _get_ots_client()
    meta = ots.describe_table(args.name)
    pk_meta = meta.table_meta.schema_of_primary_key

    with open(args.file) as fp:
        while True:
            line = fp.readline()
            if not line:
                break

            pk, attr = _get_pk_and_attr_value(pk_meta, line)
            row = Row(pk, attr)
            consumed, return_row = ots.put_row(_utf8(args.name), row)
            print "ReadCU:%s, WriteCU:%s"%(consumed.read, consumed.write)

        print "OK"

def _handle_export(args):
    pass

def gen_sub_parser():
    parser = argparse.ArgumentParser()

    subs = parser.add_subparsers(title="Sub Commands")

    # config
    sub_config = subs.add_parser('config', help="config the tablestore.")
    sub_config.add_argument("--instance", dest="instance", help="tablestore instance name")
    sub_config.add_argument("--endpoint", dest="endpoint", help="tablestore endpoint")
    sub_config.add_argument("--accessid", dest="accessid", help="tablestore accessid")
    sub_config.add_argument("--accesskey", dest="accesskey", help="tablestore accesskey")
    sub_config.set_defaults(func=_handle_config)

    # list table
    sub_lt = subs.add_parser('lt', help="list table name.")
    sub_lt.set_defaults(func=_handle_list_table)
    sub_lt = subs.add_parser('list_table', help="list table name.")
    sub_lt.set_defaults(func=_handle_list_table)

    # create table
    sub_ct = subs.add_parser('ct', help="create table name.")
    sub_ct.add_argument("--name", dest="name", required=True, help="table name")
    sub_ct.add_argument("--primary_key", dest="primary_key", required=True, 
        help="primary key. format: {ColumnName}:{Type}, type: STRING,INTEGER")
    sub_ct.add_argument("--cu", dest="cu", default="0,0", help="reserved capacity unit, defaut: 0,0")
    sub_ct.add_argument("--ttl", dest="ttl", default="-1", help="time to live")
    sub_ct.add_argument("--version", dest="version", default="1", help="max version")
    sub_ct.set_defaults(func=_handle_create_table)
    sub_ct = subs.add_parser('create_table', help="create table name.")
    sub_ct.add_argument("--name", dest="name", required=True, help="table name")
    sub_ct.add_argument("--primary_key", dest="primary_key", required=True, help="primary key")
    sub_ct.add_argument("--cu", dest="cu", default="0,0", help="reserved capacity unit")
    sub_ct.add_argument("--ttl", dest="ttl", default="-1", help="time to live")
    sub_ct.add_argument("--version", dest="version", default="1", help="max version")
    sub_ct.set_defaults(func=_handle_create_table)

    # delete table
    # TODO  add force
    sub_dt = subs.add_parser('dt', help="list table name.")
    sub_dt.add_argument("--name", dest="name", required=True, help="table name")
    sub_dt.set_defaults(func=_handle_delete_table)

    # put row
    sub_pr = subs.add_parser('pr', help="put a row")
    sub_pr.add_argument("--name", dest="name", required=True, help="table name")
    sub_pr.add_argument("--primary_key", dest="primary_key", required=True, help="primary key")
    sub_pr.add_argument("--attribute", dest="attribute", required=True, help="attribute column")
    sub_pr.set_defaults(func=_handle_put_row)

    # get row
    sub_pr = subs.add_parser('gr', help="get a row")
    sub_pr.add_argument("--name", dest="name", required=True, help="table name")
    sub_pr.add_argument("--primary_key", dest="primary_key", required=True, help="primary key")
    sub_pr.set_defaults(func=_handle_get_row)

    # get row
    sub_pr = subs.add_parser('scan', help="scan the specify range data.")
    sub_pr.add_argument("-n", "--name", dest="name", required=True, help="table name")
    sub_pr.add_argument("--begin", dest="begin", help="begin primary key")
    sub_pr.add_argument("--end", dest="end", help="end primary key")
    sub_pr.add_argument("--limit", dest="limit", help="count of return rows.")
    sub_pr.add_argument("--cond", dest="cond", help="quert condition")
    sub_pr.add_argument("--columns", dest="columns", help="return columns")
    sub_pr.add_argument("--direction", dest="direction", default="FORWARD", help="FORWARD|BACKWARD, default: FORWARD")

    sub_pr.add_argument("--pagesize", dest="pagesize", default=100, help="default show page size")
    sub_pr.add_argument("--interval", dest="interval", default=0, help="default show interval")
    sub_pr.set_defaults(func=_handle_get_range)

    # import 
    sub_import = subs.add_parser('import', help="import data of file to tablestore")
    sub_import.add_argument("--name", dest="name", required=True, help="table name")
    sub_import.add_argument("--file", dest="file", required=True, help="import data file")
    sub_import.set_defaults(func=_handle_import)

    # export 
    sub_export = subs.add_parser('export', help="export data of tablestore to file")
    sub_export.add_argument("--name", dest="name", required=True, help="table name")
    sub_export.add_argument("--file", dest="file", required=True, help="export data file")
    sub_export.set_defaults(func=_handle_export)

    return parser

class InteractiveCmd(cmd.Cmd):
    prompt = "tablestore> "
    def _load_cmd(self):
        try:
            with open(GLOBAL_HISTORY_FILE) as fp:
                return json.load(fp)
        except Exception, e:
            return []

    def _save_cmd(self):
        try:
            with open(GLOBAL_HISTORY_FILE, "w") as fp:
                length = len(self.cmds)
                if length > 10:
                    fp.write(json.dumps(self.cmds[length - 10:length], indent=4))
                else:
                    fp.write(json.dumps(self.cmds, indent=4))

        except Exception, e:
            pass
   
    def init(self, parser, args):
        self.cmds = self._load_cmd()
        self.parser = parser
        self.args = args
        return self

    def do_cmds(self, line):
        for c in self.cmds:
            print c

    def do_quit(self, line):
        self._save_cmd()
        print "Bye"
        sys.exit(0)

    def do_help(self, line):
        self.default(line)

    def default(self, line):
        if not line:
            return
        self.cmds.append(line)

        argv = line.split(' ')
        result = self.parser.parse_args(argv)
        result.func(result)

# 命令模式 
def command_mode(parser, args):
    argv = args.cmd.split(' ')
    result = parser.parse_args(argv)
    result.func(result)

def _handle_mode(args):
    global GLOBAL_CONF
    GLOBAL_CONF = _get_ts_config()
    sub_parser = gen_sub_parser()
    if args.cmd:
        command_mode(sub_parser, args)
    else:
        print "Aliyun TableStore Command Line Tool\nVersion %s \n@Copyright 2017 Alibaba Cloud Computing Co., Ltd. All rights reserved." % (VERSION)
        InteractiveCmd().init(sub_parser, args).cmdloop()

def gen_mode_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", dest="cmd", help="command mode.")
    parser.set_defaults(func=_handle_mode)
    return parser

if __name__ == '__main__':
    parser = gen_mode_parser()
    result = parser.parse_args(sys.argv[1:])
    result.func(result)


